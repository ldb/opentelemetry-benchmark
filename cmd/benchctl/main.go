package main

import (
	"bufio"
	"flag"
	"fmt"
	"github.com/ldb/openetelemtry-benchmark/benchmark"
	"github.com/ldb/openetelemtry-benchmark/command"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"
)

var (
	configFlag = flag.String("config", "benchctl.config", "config file generated by terraform")
	planFlag   = flag.String("plan", "", "benchmarking plan to execute")
)

func main() {
	flag.Parse()
	if *configFlag == "" || *planFlag == "" {
		flag.PrintDefaults()
		return
	}

	plan, err := createPlan(*configFlag, *planFlag)
	if err != nil {
		log.Fatalf("error generating benchmarking plan: %v", err)
	}

	reader := bufio.NewReader(os.Stdin)
	fmt.Printf("parsed the following plan:\n%+v\n", plan)
	fmt.Println("do you want to apply this plan? [Y/n]")
	t, _ := reader.ReadString('\n')
	if t != "yes\n" && t != "y\n" && t != "\n" {
		fmt.Println("ok, aborting")
		return
	}
	fmt.Printf("applying plan %q\n", plan.Name)
	client := command.NewClient(plan.ClientAddress)
	status, err := client.CreateBenchmark(plan.Name)
	if err != nil {
		log.Fatalf("error creating benchmark: %v", err)
	}
	status, err = client.ConfigureBenchmark(plan.Name, plan.BenchConfig)
	if err != nil {
		log.Fatalf("error configuring benchmark: %v", err)
	}
	if status.State != benchmark.Configured.String() {
		log.Fatalf("benchmark not configured. current state: %+v", status)
	}
	fmt.Println("plan applied.")
	fmt.Println("do you want to start this plan? [Y/n]")
	t, _ = reader.ReadString('\n')
	if t != "yes\n" && t != "y\n" && t != "\n" {
		fmt.Println("ok, aborting")
		return
	}

	c := make(chan os.Signal)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM)
	fmt.Println("starting plan. use ^C to stop the plan")

	status, err = client.StartBenchmark(plan.Name)
	if err != nil {
		log.Fatalf("error starting benchmark: %v", err)
	}
	if status.State != benchmark.Running.String() {
		log.Fatalf("benchmark not running. current state: %+v", status)
	}
	planDuration := time.After(plan.Duration.Duration)
outer:
	for {
		select {
		case <-planDuration:
			fmt.Println("plan finished.")
			break outer
		case <-time.Tick(time.Second):
			status, err = client.Status(plan.Name)
			if err != nil {
				log.Fatalf("error getting benchmark status: %v", err)
			}
			fmt.Printf("%+v\n", status)
		case <-c:
			fmt.Println("\r received signal. stopping plan..")
			break outer
		}
	}
	status, err = client.StopBenchmark(plan.Name)
	if err != nil {
		log.Fatalf("error stopping benchmark: %v", err)
	}
	if status.State != benchmark.Stopped.String() {
		log.Fatalf("benchmark not stopped. current state: %+v", status)
	}
	fmt.Printf("%+v\n", status)

	logsURL := ""
	fmt.Printf("plan stopped. you can download the logs here: %s\n", logsURL)

	fmt.Println("do you want to destroy the plan? \033[31m WARNING THIS WILL DESTROY YOUR LOG FILES \033[0m. Proceed? [y/N]")
	t, _ = reader.ReadString('\n')
	if t != "yes\n" && t != "y\n" {
		fmt.Println("ok, aborting")
		return
	}
	status, err = client.DestroyBenchmark(plan.Name)
	if err != nil {
		log.Fatalf("error destroying benchmark: %v", err)
	}
	fmt.Printf("%+v\n", status)

}
